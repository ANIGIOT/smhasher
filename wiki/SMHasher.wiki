#summary SMHasher info

== Sanity Tests ==

== Performance Tests ==

== Differential Tests ==

== Avalanche Tests ==

Do all key bits affect all hash bits equally? Does flipping a key bit cause all hash bits to flip with a 50/50 probability?

For an N-bit hash function, SMHasher generates 2 million N*2-bit keys and flips each bit of each key, comparing the original hash of the key and the hash of the flipped-bit key. It computes how far the flipping of each output bit is from an ideal 50/50 probability, and reports the worst deviation or 'bias' from ideal it found - 0% indicates perfect 50/50 probability, 100% indicates that the output bit either never or always flipped.

Due to random fluctuations we generally won't see exactly 50/50 even with true random inputs, but 2 million tests is enough to measure bias down to about 0.25%

== Cyclic Keyset Tests ==

These keysets break MurmurHash2, and were the motivation for creating MurmurHash3.

== Sparse Keyset Tests ==

These keysets are similar to the ones generated by Bob Jenkins' 'frog.c' test code.

== Permutation Keyset Tests ==

Ten blocks of key data can be assembled into a key in ~3.6 million ways. If each block only has a single bit set, the resulting keys are very hard to hash well - there's just not much data there to work with.

== Windowed Keyset Tests ==

This is more of a sanity check than a difficult keyset to hash. Given an N-bit hash, generate all possible N*2-bit keys that have a contiguous 20-bit-wide "window" of bits set to all possible 2^20 values.

If nearby bits in the key tend to cancel each other out in the hash function, this should produce a lot more random collisions than expected.

== Text Keyset Tests ==

This is a convenient place for users to create keyset patterns that match those found in their own applications.

Given a prefix string P, a suffix string S, a set of characters C, and a length value L, generate all possible keys of the form P+[L characters from C]+S and test their collision + distribution properties.